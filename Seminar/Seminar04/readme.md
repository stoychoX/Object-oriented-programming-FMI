# Семинар 04
*Резюме: Разглеждаме нуждата от член-функции. Разглеждаме модификатори. Въвеждаме идеята за капсулация. Запознаваме се с конструктори и деструктори и разглеждаме кога се извикват.*

## Член-функции
Член-функциите са функции, които работят с член-данните на класа. 

```cpp
struct Exmaple {
    int number;

    bool isNumberPositive() const {
        return number > 0;
    }
};

int main() {
    Example e;
    e.x = 10;
    std::cout << e.isNimberPositive();
}
```

> Няма значение колко член-функции имаме. Размерът на класа/структурата зависи само от променливите.

Този пример може да доведе до няколко въпроса.
---
### Какво се случва??
* isNumberPositive е функция, която е обвързана със структурата Example. Тя може да се викне от всеки обект от тип Example и отговаря на въпроса дали number е положително. От тук можем да си направим извод, че **член-функциите работят с член-данните на класа.**
---
### Какво е const?
* Когато проверяваме дали number е по - голямо от 0 това не включва промяна на нито една от член-данните. Следователно можем да декларираме функцията като const, тоест, че тя не променя член-данните. Защо ни помага това?

```cpp
void f(const Example& e) {
    // Ако не е конст не можем да я викаме.
    // Все пак как ще викаме функция, която може да промени
    // обекта когато обекта е константен?
    e.isNumberPositive(); 
}
```
---
### Какво се случва??
В предишните семинари тази функционалност би била написана по следния начин:
```cpp
void isNumberPositive(const Example& e) {
    return e.number > 0;
}
```

Е, компилатора решава да ни спести малко писане. Момента в който дефинираме такава член-функция той генерира автоматично за нас следното:
```cpp
void isNumberPositive(const Example* const this) {
    return this->number > 0;
}
```
---
### Защо просто не си пиша number > 0
В случая е възможно да се направи така. Когато обаче имаме повече член-данни, които са по - комплекси и имплементираме някаква по - сложна логика използвайки ги е страшно удобно да имаме член-функции. Не само, че кодът става по - четим а и можем да разбием самата задача на подзадачи и за всяка подзадача да отговаря точно една функция.

## Жизнен цикъл на обект. Конструктор и деструктор.
Всеки обект има жизнен цикъл.
1. Създаване на обект.
2. Използване на обекта.
3. Унищожаване на обекта.

Понягока искаме когато създаваме обект да имаме **логика по която той се създава**. Функцията, която имплементира тази логика наричаме **конструктор**.
Симетрично, искаме да имаме **логика по която той се унищожава**. Функцията, която имплементира тази логика наричаме **деструктор**.

```cpp
struct Entity {
    int x;
    int y;
    char data[8];

    // Това се нарича конструктор по подразбиране
    // или по често срещан като default constructor
    Entity() {
        std::cout << "Called constructor" << std::endl;
        x = 42;
    }

    Entity(int argx, int argy) {
        x = argx;
        y = argy;
    }

    // Деструктор
    // Не е добра идея да се вика cout в клас!
    // Тук се вика изцяло с цел да видим, че се извиква.
    ~Entity() {
        std::cout << "Called destructor" << std::endl;
    }
};

int main() {
    // Точно сега се вика default конструктора
    Entity e;

    // Правим нещо с този обект...
    std::cout << e.x << std::endl; // извежда се 42
} // Деструктора се вика в края на скоупа в който е дефиниран (статичния) обект. При динамичните е малко по - различно.
```

**Ако не създадем никакви конструктори компилаторът създава конструктор по подразбиране.** Можем да имаме различна логика по създаване на обекти следователно можем да имаме и конструктори с параметри.
Ако създадем само конструктор с параметри **default конструктор не се създава.*

## Композиция. Извикване на конструктори и деструктори в композиция.
Може да видите пример как се извикват конструкторите при композиция в ```constructor-example.cpp```

## Капсулация - ограничаване на достъпа
**Идеята на капсулацията е да ограничи достъпа така, че данните винаги да са валидни.**

Капсулацията (encapsulation) е един от основните принципи на ооп. Не винаги всички член-данни трябва да се достъпват свободно от всички потребители. Достъпването на тези член-данни се получава чрез подходящ интерфейс, който гарантира, че информацията ще остане консистентна.

## Модификатори за достъп.

```
private - Прави член-данните невидими за външния свят.
protected - Скоро.
public - Всеки може да достъпва член-данните.
```

```cpp
struct Example {
private:
    int privateIndex;
public:
    int publicIndex;
};

int main() {
    Example e;
    e.privateIndex = 0; // Грешка!
}
```

## Извикване на конструктори в масиви
При заделяне на статичен масив default конструкторите се викат за всеки обект в статичния масив. Деструкторите им се викат при края на скоупа в който са декларирани.

Когато заделяме динамично обекти/масиви това не е точно така. Ключовата дума **new** заделя памет и извиква конструктора. Деструктора обаче се извиква когато извикаме **delete**.

```cpp
int main() {
    Example* e;

    {
        e = new Example;        // Вика се default конструктор
        Example e1[10];         // Викат се 10 конструктора за всеки обект в масива
    } // Викат се 10 деструктора за всеки обект в е1

    delete e; // Вика се деструктор на е
}
```

## get и set функции
Когато член-данните са private може все пак да искаме да ги четем или променяме по някакъв начин. Идеята е този начин да е контролиран. Този контрол се осъществява благодарение на мутаторите (сетъри) и селекторите (гетъри).

Може да висите примери за гетъри и сетъри в ```Time.cpp```. Примерно, функцията setHours променя часовете, но само ако подаденият аргумент е коректен.