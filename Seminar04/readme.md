# Четвърти семинар по обектно ориентирано програмиране ИС - 13.03.2025

## Резюме
1. Обединения. Битови полета.
2. Разделна компилация.

## Обединения (union)
Обединение (или union) е специфична конструкция в езиците С/С++, която може да представлява само една от (не статичните си) член данни в един момент.

Начинът, по който създаваме обединение, е еквивалентен на начина, по който създаваме структура.

```cpp
union Example
{
    int x;
    short y;
    char z;
};
```

Разликата тук, е че структурата може да представи и трите променливи по едно и също време. Обединението (във всеки един момент) представлява или x или y или z.

Те споделят една памет - размерът на `Example` е размерът на най - голямата му член данна (в случая `sizeof(int)`). Останалите член данни (с по - малък или равен размер) споделят паметта на най - голямата.

Достъпване на променлива, която не е била последно променената, е undefined behaviour.

## Битови полета
Битовите полета (или bitfields) декларират член-данна на структура (или клас), за които сме указали специфичен размер в битове. Нека разгледаме следния пример:

```cpp
struct BitFieldExample
{
    // We can only use 3 bits of the 32 bit
    // unsigned variable! Rest are padding.
    unsigned b : 3;
};
```
В случая b има стойности от 0 до 7. Размера на структурата не се променя!

Битовите полета се използват в случаи в които работата с памет е наложителна. Една примерна имплементация на структура, представляваща състоянията на поток би била следната:

```cpp
struct StreamState
{
    unsigned char good_bit : 1;
    unsigned char bad_bit : 1;
    unsigned char fail_bit : 1;
    unsigned char eof_bit : 1;
};
```

Това до някъде улеснява работата със състояния, работещи чрез битове (побитови операции).

Една примерна имплементация на структура, правата на файл (кой може да чете или пише от него) би била следната

```cpp
struct FilePermissions 
{
    // owner permissions
    unsigned int owner_read    : 1;
    unsigned int owner_write   : 1;
    unsigned int owner_execute : 1;

    // group permissions
    unsigned int group_read    : 1;
    unsigned int group_write   : 1;
    unsigned int group_execute : 1;

    // other permissions
    unsigned int other_read    : 1;
    unsigned int other_write   : 1;
    unsigned int other_execute : 1;
};
```

## Разделна компилация.
Компилацията на един С++ проект е сложен процес. Все пак, най-просто казано, целта ни е от един (или повече) файла, съдържащи код написан на С++, да създадем изпълним файл, който представлява нашата програма. Изпълнимите файлове (.exe, .out) са файлове, които операционната система знае как да зареди и изпълни. Това са нашите програми. Но как точно се създават те?

Можем да разбием процесът на създаване на програма на следните стъпки:
1. Preprocessor - обработват се всички препроцесорни директиви.
2. Compilation  - С++ се свежда до assembly и от там до object file (.obj, .o)
3. Linking

## Какво представлява препроцесора
Нека първо разгледаме какво представляват препроцесорните директиви. Тези, които ние ще разгледаме, са:
* #include
* #define
* #ifndef

Препроцесорните директиви започват със символа #. 

## include

Неформално - добавя файл в нашия файл.

Нека имаме следните два файла:
![](media/include.png)

След изпълняването на препроцесора файла `src.cpp` би изглеждал по следния начин:

![](media/preprocessed.png)

От уводния курс по програмиране познаваме директивата `#include`. Използвахме я в следния контекст `#include<iostream>`. В случая обаче не използваме символите `<>` а използваме `""`. И двата синтаксиса правят едно и също - добавят някакъв файл към нашия файл. Разликата е как търсят този файл:

* Използвайки синтаксиса `#include"..."` търсим файла по подаден път.
* Използвайки синтаксиса `#include<...>` търсим файла в някоя от предварително зададените директории в която се съдържат нашите библиотеки.

Наистина, би било неудобно да пишем всеки път дълги пътища за да намираме файловете си. Можем да зададем така наречените include директории в които нашия компилатор да търси файловете. Стандартните библиотеки като `iostream`, `cmath` и тн. се намират в директории, които са предварително известни за компилатора. Ако искаме същото поведение с наши библиотеки можем да добавим наша директория към include директориите.

Можем да подаваме всякакви файлове използвайки `#include`, но скоро ще видим, че това не е особено добра идея.

## define
Чрез препроцесорната директива `#define` дефинираме така наречените макрота (macros). Те не са нищо повече от замяна на един текст в друг.
Синтаксис:

```cpp
#define identifier replacement
```

нека разгледаме следния файл:

```cpp
#define FIVE 5

int main()
{
    return FIVE;
}
```

След препроцесването файлът изглежда така:

```cpp
int main()
{
    return 5;
}
```

Това е изключително удобно в някои случаи - можем да даваме други имена на неща, можем да "симулираме" глобални константи (които обаче не заемат памет). И разбира се, ако не внимаваме може и да счупим нещо

```cpp
#define true false
```

Можем да подаваме и аргументи на написаните от нас макрота:
```cpp
#define SQUARE(x) ((x) * (x))
int result = SQUARE(5);
```

Можем също така просто да дефинираме някакви макрота без стойност:

```cpp
#define VERSION_1_1
```

## #ifndef
Препроцесорната директива #ifndef проверява дали макро е дефинирано.
Това може да бъде полезно в много случаи.

```cpp
#ifndef VERSION_1_1
    std::cout << "Not running on version 1.1";
#else
    std::cout << "Running on version 1.1";
#endif
```
Както виждаме от примера, трябва да завършим проверката с `#endif`. Също така имаме възможност да окажем какво се случва, ако макрото е дефинирано.

## Компилация - но накратко!
След като препроцесора е свършил работата си, идва момента на компилацията. В резултат на нея се получават един (или повече) обектни файлове. Обектните файлове представляват машинен код, метаинформация за кода и символи (имена на функции, променливи, класове и тн.).

Компилацията е наистина сложен процес, включващ много оптимизации, анализи и стъпки, които често остават скрити за нас. Най-честата схема, по която се случва компилацията е, че C++ кодът се превръща в код на езика Assembly. Assembly е език, който е близък до машинния код. От там изходът се превръща (чрез асемблер) в машинен код (.obj, .o).

В дъното на всичко е превръщане на един текстов файл (.cpp) в един двоичен файл (.obj). 

Ако пишем всичко в един .cpp файл, цялото това превръщане ще стане **твърде бавно** (и не говорим за забавяне от порядъка на минути). 
Но защо да пишем всичко в един С++ файл? Все пак големите проекти могат да се разбият на много компоненти. Не можем ли да разбием кода си на много cpp файлове?

Можем (и е добре да го правим). Точно от там идва термина **разделна компилация.** Какво е предимството? Нека си представим проект, който има 2000 cpp файла. Нека също те са компилирани и имаме нужда да направим промяна в един от тях. Тогава ще се компилира **единствено този файл** и останалите файлове няма да се променят! Това прави компилацията **в пъти** по-бърза. Никой няма време да чака ден да се компилира промяна на 2 реда.

Твърдението, че единствено променения файл ще се компилира звучи много хубаво. То е истина ако предпоставката, че единствено този файл е промененя е истина. Ако променяме файл, който е инклуднат в други файлове, то и те се променят въпреки, че не ги променяме пряко.

Споменахме, че разбиваме проекта си на различни компоненти. Тези компоненти независими ли са, или една компонента може да използва функции/класове и т.н. от друга?

## Разделяне на .h и .cpp файлове
Тук идва тънкостта на разделната компилация. Стандартно, всяка компонента представлява двойка от `.h` и `.cpp` файл. Ние знаем какво е `.cpp` файл. Файловете с разширение `.h` от `header` или на български заглавни файлове **съдържат единствено дефинициите на функциите, класовете и т.н. които ще използваме.** В `.cpp` файловете се съдържа имплементацията на тези функции/класове.

Нека под *символ* разбираме всяка единица която може да се именува - променливи, функции, класове, константи, enum...

Неформално можем да си мислим следното:
Заглавните файлове **обещават** че някакъв символ съществува. Реализацията на този символ се намира в друг `.cpp` файл и се **компилира отделно.** 

Тоест, ако искаме да използваме символ от друг компонент, е достатъчно включим заглавния файл на компонента с #include и да го реализираме в cpp файла му.

## Как се намират символите? Linking
Чрез `.h` файловете давахме обещание, че някакъв символ съществува. Това обещание обаче трябва някой ден да се случи - все пак накрая всичко завършва в един изпълним файл. След като се компилират отделно всички `.cpp` файлове получаваме няколко `.obj` файла. В някои от тях има обещания за съществуването на някакви символи. Работата на linking частта е да свърже обещаните символи с реализациите им. Тоест ако `A.cpp` очаква `void f()`, който е в `B.cpp` (и е обещан от `B.h`), то линкърът ще направи тази връзка. 

След като връзките биват изградени получаваме така желания изпълним файл.

# pragma once
Има опасност да вмъкнем един и същ `.h` файл два пъти. Това би довело до грешка, понеже тогава ще станат две декларации, които са едни и също. За да избегнем това поведение използваме препроцесорната директива `#pragma once`. Пишем я в началото на всеки `.h` файл.

* Защо не е добре да include-ваме .cpp файлове?
* Добри практики при работа със структури.

## Задача първа
