# Шести семинар по обектно ориентирано програмиране - 27.03.2025

## Резюме
1. Селектори и мутатори
2. Капсулация
3. Класове и обекти - жизнен цикъл

## Капсулация.
Споменахме, че член данните могат да бъдат декларирани като `private`. Това ги прави невидими за външния свят. Със същия успех можем да декларираме и член функции като `private`. Скриването на информацията ни помага да имаме по-добра **капсулация**. Капсулацията е един от основните принципи на обектно ориентираното програмиране. 

Тя налага разбиването на един клас на интерфейс и имплементация. Интерфейсът представлява набор от операции, които потребителят може да изпълнява свободно по начин, който не "бърка" в имплементацията. Понякога искаме потребителите да нямат достъп до всички член-данни и методи на даден клас. Това е така, защото тяхната промяна може да доведе до неочаквано поведение на нашата програма. Принципът за капсулация ни помага като позволява да определим кои методи и атрибути може да използват потребителите на нашия клас.

## Селектори и мутатори.
Когато член данните са декларирани като `private` те са скрити от външния свят, но това не означава, че не можем да ги променяме използвайки член функции.

```cpp
class Entity
{
private:
    int x = 0;
public:
    void set(int argx)
    {
        x = argx;
    }

    int get() const
    {
        return x;
    }
};

int main()
{
    Entity e;
    // std::cout << e.x; - Грешка, х е private!
    e.set(10);
    std::cout << e.get(); // Извежда 10
}
```

Какъв е смисъла да скриваме член данните и да ги променяме през функции? Смисъла е, че по този начин можем да наложим някакви ограничения за стойностите им. Възможно е не всяка стойност, която типът може да приема, да е валидна стойност. Члез `set` функциите налагаме ограничения като можем да не допуснем някоя стойност.

## Задача първа 
Реализирайте клас Time, който ще се използва за работа с часове (13:05:45). Вашият клас трябва да има следния интерфейс:

* Подразбиращ се контруктор, който създава часа на 00:00:00.
* Конструктор, който приема три параметъра - час, минути и секунди.
* Член-функция, която връща оставащото време до полунощ.
* Член-функция, която увеличава часа с 1 секунда.
* Член-функция, която връща дали е време за вечеря. В рамките на задачата време за вечеря е между 20:30 и 22:00.
* Член-функция, която приема друг обект от тип Time и връща обект от тип Time, което е разликата между двете времена.
* Член-функция, която която приема друг обект от тип Time и сравнява двата обекта (по-къснен/по-ранен)
* Член-функция за принтиране на часа.

## Голяма четворка
В уводния курс разбрахме, че ако не подадем по референция аргумента се прави копие. Това важи както за примитивните типове от данни така и за класовете и структурите създадени от нас. Това е и причината на константните референции да се обръща специално внимание - при големи обекти копието е скъпо. Но как точно става копието при създадени от нас класове? Възможно ли е да имплементираме наша логика за копиране?

Да. С копирането на един обект в някакъв смисъл започва живота на друг, та логиката за копиране е естествено да се описва в конструктор. Когато създаваме клас или структура следните четири се генерират автоматично за нас:

* Конструктор по подразбиране
* Копиращ конструктор - съдържа логиката за копиране на обект
* Оператор за присвояване - съдържа логиката за присвояване на обект
* Деструктор

С конструктора по подразбиране и деструктора се занимавахме подробно миналия път.

```cpp
class Entity
{
    A a;
    B b;
    C c;
};

int main()
{
    Entity e; // Конструктор по подразбиране.
    Entity e1(e); // Копиращ конструктор.
    e = e1; // Оператор за присвояване.
} // Деструктор на e и e1.
```

### Как работят дефинираните от компилатора функции
Всяка една от тези функции **извиква 'рекурсивно' същите функции върху член-данните**.

### Конструктор за копиране - синтаксис и пример
В конструктора за копиране държим логиката по копиране на обекта (както името може да подскаже).
Нека разгледаме следния пример:

```cpp
#include <iostream>

class Entity
{
private:
	int x;
public:
	Entity(int x) : x(x) {}

	int get() const
	{
		return x;
	}
};

void f(Entity e)
{
	std::cout << e.get();
}

int main()
{
	Entity e(12);
	std::cout << e.get() << std::endl;
	f(e);
}
```
В случая на обекта Entity му се прави копие. копиращия конструктор отговаря за това копие а той е автоматично генериран от компилатора. Очакваното поведение е да копира всички член данни. В случая имаме една променлива от тип int (и знаем как се копират тези променливи). Следователно е ясно какво ще стане тук - ще се изведе два пъти 12.

Нека се опитаме (за примера) да променим малко кода. Нека в Entity класът добавим следния публичен ред:
```cpp
// конструктор за копиране
Entity(const Entity& other) : x(2 * other.x) {}
```

Това е конструктор, който приема константна референция към друг обект. **Обектът, който се създава копира подадения по референция обект!**. Все пак това е С++, та имаме контрол над това как се случва копирането. Какво ще изведе кодът след като добавихме този ред?

Ще изведе 12 и 24. След имплементирането на наша логика за копиране новосъздадения обект има стойност **два пъти по-голяма от обектът, който използва за да се копира.**

* Какво се случва ако класът ни държи референция като член данна?

### Оператор за присвояване - синтаксис и пример.
В оператора за присвояване се съдържаа логиката за присвояване на обект (какво става когато напишем e1 = e2 където и двата обекта са вече изградени).

```cpp
#include <iostream>

class Entity
{
private:
	int x;
public:
	Entity(int x) : x(x) {}

	// конструктор за копиране
	Entity(const Entity& other) : x(2 * other.x) {}

	int get() const
	{
		return x;
	}
};

int main()
{
	Entity e(12);
	
    // Тук се използва оператор за присвояване, но се създава нов обект.
    // В случая се вика копиращ конструктор. Това е еквивалентно на 
    // Entity e1(e).
	Entity e1 = e;

	Entity e2(14);

    // Колко ще е стойността на e2.get()?
	e2 = e;

	std::cout << e.get() << " " << e1.get() << " " << e2.get();
}
```

В случая отново ще се случи очакваното - e има стойност 12, e1 има стойност 24 заради копиращия конструктор а e2 има стойност 12.
Можем ли да направим наша логика за присвояване? Да - нека добавим следния публичен ред в класа Entity:

```cpp
Entity& operator=(const Entity& other)
{
	x = other.x / 2;
    return *this;
}
```

Сега при присвояване обектът от лявата страна ще има два пъти по - малка стойност от десния. Нека забележим, че ```operator=``` връща референция към текущия обект. Това е очаквано, най-малкото искаме да можем да правим неща като ```e1 = e2 = e3```. Това са две изпълнения на ```operator=``` и за да се изпълни второто то има нужда от референция (която първото изпълнение връща).

### Проблем с генерираните от компилатора функции
Нека разгледаме следния пример от последния семинар:
```cpp
#include <iostream>
#include <cstring>

class Entity
{
private:
    char* label;

    void free()
    {
        delete[] label;
    }
public:
    Entity() : label(nullptr) {}

    Entity(const char* c) 
    {
        size_t len = strlen(c);
        label = new char[len + 1];
        strncpy(label, c, len);
        label[len] = '\0';
    }

    const char* getLabel() const
    {
        return label;
    }

    ~Entity()
    {
        free();
    }
};

int main()
{
    Entity e("label value");
    Entity e1(e);
}
```
Следния пример ни води до проблем. Къде е проблема???
* Създава се обект е - за него се заделя памет
* Създава се обект е1 - на него му се вика конструктор за копиране
* Конструктор за копиране рекурсивно копира всички член данни. Тук има една член данна.
* Сега e1::label е копие на e::label
* Два копирани указателя имат различен адрес в паметта, но **сочат към една и съща памет**
* Първо се вика деструктора на е - той трие паметта към кояно сочи e::label
* След това се вика деструктора на e1 - той трие паметта към която сочи e1::label, но **тя вече е изтрита!**. Това води до проблем.

Къде е проблема тук? Проблема е, че очакваме **друго поведение при копиране на указателя**. Това е така нареченото **shallow copy**. Вече знаем как да направим наша логика по копиране - нека оправим проблема:

```cpp
Entity(const Entity& other)
{
    label = new char[strlen(other.label) + 1] {};
    strcpy(label, other.label);
    // Ако имаме други член данни трябва да се погрижим и за техните стойности!!!
}
```
сега вече не правим копие на указателя а заделяме нова памет. Кодът обаче има още един проблем:

```cpp
int main()
{
    Entity e("label value");
    Entity e1(e);

    e = e1;
}
```
Това чупи програмата ни, но защо? Става нещо подобно както с конструктора. Отново се случва неправилно копиране на указателя и го трием два пъти. 

Проблема решаваме по следния начин:

```cpp
Entity& operator=(const Entity& other)
{
    if (this != &other)
    {
        free();
        label = new char[strlen(other.label) + 1] {};
        strcpy(label, other.label);
    }
    return *this;
}
```

Нека хвърлим малко светлина:
* Проверката ```this != &other``` ни спасява да не напишем нещо от сорта на ```e = e```. Сравнява се **по адрес а не по стойност** - ```this``` е указател &other връща адрес.
* free() - преди да заделим място за новата стойност трябва да изтрием старата. Иначе става отечка.
* Следващите два реда трябва да се изнесат във функция. Тази логика я имаме в копиращия конструктор както и в оператора за присвояване - нека не дублираме код.
* return *this - връща референция към текущия обект.

Финалната версия е качена в `big-four.cpp`. 

При липсата на външен ресурс често не разписваме тези функции - генерираните от компилатора ни вършат достатъчно добра работа.
Когато работим с такъв обаче е добре да разпишем четирите функции. Също следната конвенция важи:
* Логиката за изтриване **се извежда във отделна функция**
* Логиката за копиране **се извежда в отделна функция**
* Когато копираме **трябва да се порижим за всички член данни не само за динамичната памет**

## Изтриване на генерираните от компилатора функции.
* Синтаксис
* Какво се случва при копмозиция на обекти.