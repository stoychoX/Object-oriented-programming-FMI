# Осми семинар по обектно ориентирано програмиране - 10.04.2025

## Ключовата дума static
Можем да използваме `static` в три различни контекста.

### static променливи във функции
```cpp
#include<iostream>

void f() 
{
    static int i = 0;   // Инициализира се веднъж
    i++;
    std::cout << i << std::endl;
}

int main() 
{
    f();
    f();
    f();
}
```
`Изход: 1, 2, 3`

Променливите декларирани във функция като статик се инициализират точно веднъж.

### static функции
```cpp
static void f() 
{
    // some work...
}
```
Статичните функции в някакъв смисъл са единствено предназначени само за .cpp файла в който са дефинирани. По подразбиране функциите са глобални, т.е. други .cpp файлове могат да ги виждат и да ги използват. Това може да доведе и до проблеми със свързването (linking), примерно когато се дублират имена. 

Този тип функции също се използва като оптимизация за linker-ът. Еквивалентно е на анонимния namespace изучаван на лекции.

### static в класове
```cpp
class Entity 
{
private:
    static int x; // Не принадлежи на никой обект. Споделя се между обекти. Единствена.
public:
    static void f() {
        // do work
    }
};

int Entity::x = 0;

int main() 
{
    Entity::f();
}
```
Статичните член-данни в класа са в някакъв смисъл единствени. Те не принадлежат на никой обект и отново се инициализират точно веднъж.
Статичните член-данни в класовете имат множество приложения като:
* Броене на инстанциите (създадени инстанции или живи инстанции)
* Реализация на Singleton design pattern в C++.

Можем и да имаме **статични функции в класовете**. Това са функции, които не са обвързани с обекта, НЕ могат да променят член-данните му и следователно не могат да бъдат const. За извикването им не ни трябва инстанция на класа.

## Композиция и агрегация.

## Задача първа
Да се реализира клас `SelfCounting`, който поддържа следния интерфейс:
* getAliveCount - връща броя на всички инстанции, които все още не са били унищожени.
* getCount - Връща броя на всички създадени инстанции.