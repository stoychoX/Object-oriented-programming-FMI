 # Практикум 2 (02.03.2023)

## Задача първа
От стандартния вход се прочитат три числа. Запишете във файл "result.txt" сумата и произведението им.
След приключване на програмата в result.txt са записани само сумата и произведението на въведените числа (ако преди това е имало друга информация, тя се затрива). 

Да се напише функция, която чете от файла result.txt двете записани числа и извежда разликата им на стандартния изход.

## Задача втора
Да се напише функция, която връща броя на символите във файл, които са различни от 'a' и 'd'.
hint: Какво прави функцията get()?

---
## Сериализация и десериализация
Сериализацията е процес на записване на данни в подходящ формат.
Когато бъдат прочетени отново (**десериализирани**), получаваме **идентично** копие на данните.

Нека имаме някаква структура, пазеща определена информация. Тази структура живее в паметта на нашата програма, но какво става когато спрем програмата? Данните, които тази структура пази, се губят. Какво правим, когато искаме при следващото стартиране на програмата отново да имаме тези данни?

Едно решение е да ги **сериализираме** във файл. Следващия път, когато имаме нужда от тях, просто ги **десериализираме**.

---

## Задача трета
Да се създаде структура pair, която представлява наредена двойка от естествени числа.
Да се реализират следните функции:
* pair createPair(int x, int y); - Връща двойка с елементи x и y.
* void initPair(pair& toInit, int x, int y); - Дава стойности x и y на toInit.
* pair readPairFromFile(std::ifstream& inFile); - Прочита двойка от файл.
* void writePairToFile(std::ofstream& outFile, const pair& toWrite); - Записва двойка във файл.

Да се създаде структура, която представлява релация с най-много 25 наредени двойки. Структурата също трябва да пази колко наредени двойки имаме до този момент. Реализирайте функции:
* bool addPair(relation& arg, pair& toInsert); - Добавя нова наредена двойка, ако има място. Ако няма връща false.
* bool writeRelation(const relation& arg, const char* filePath) - Записва (сериализира) релацията във файл.
* bool readRelation(relation& arg, const char* filepath) - Прочита (десериализира) релацията от файл.

Начинът, по който програмата чете и записва обектите във файлове, е ваша отговорност.

## Задача четвърта
Да се реализира структура, която представлява запис (log). Записът се представя като:
* Име на потребител с дължина 16
* ip(v4) адрес на потребителя (спомнете си как представихме ip адрес на лекции за улеснение)
* Час, минути и секунди на логът (можете да направите отделна структура за това, за която да имате помощни функции)

Да се реализират:
* bool writeLog(const log& toWrite, std::ofstream& outFile); - записва лог във файл.
* bool writeLogs(log* logs, size_t size, const char* filePath); - Записва масив от логове във файл
* bool readLog(log& toRead, std::ifstream& inFile); - прочита лог от файл
* size_t logsCount(const char* filePath); - Връща броя на логовете записани във файл
* size_t readLogs(log* logs, const char* filePath); - Прочита логовете от файл и връща броят им. Ако възникне грешка функцията връща 0.

Помислете как ще реализирате записването във файл, така че четенето да е максимално лесно.

## Задача пета
Да се реализира структура, която моделира потребител в дадена информационна система. За всеки потребител трябва да се пазят:
* потребителско име - дължина до 32 символа, може да съдържа букви, цифри, -, _, .
* парола - най-малко 8 символа, най-много 32, трябва да съдържа поне една главна буква, малка буква и цифра (за улеснение нека приемем, че паролата се пази в чист вид, макар това да е изключително лоша практика в реалните информационни системи!)
* имейл адрес - дължина до 32 символа

Потребителите във вашата информационната система се съхраняват в един CSV файл, като те не могат да надброяват 100.
Потребителското име е уникално за всеки потребител.
НЕ може да има повече от един потребител, регистриран с даден имейл адрес.

Да се реализират следните функционалности:
* Добавяне на нов потребител.
* Вход в системата посредством потребителско име и парола.
* Промяна на паролата (след вход в системата).

Обърнете внимание на ограниченията при имплементацията на всяка от функционалностите!

Реализирайте подходящ интерфейс на конзолата за всяка от имплементираните функционалности на вашата информационна система.
 # Практикум 2 (02.03.2023)

## Задача първа
От стандартния вход се прочитат три числа. Запишете във файл "result.txt" сумата и произведението им.
След приключване на програмата в result.txt са записани само сумата и произведението на въведените числа (ако преди това е имало друга информация, тя се затрива). 

Да се напише функция, която чете от файла result.txt двете записани числа и извежда разликата им на стандартния изход.

## Задача втора
Да се напише функция, която връща броя на символите във файл, които са различни от 'a' и 'd'.
hint: Какво прави функцията get()?

---
## Сериализация и десериализация
Сериализацията е процес на записване на данни в подходящ формат.
Когато бъдат прочетени отново (**десериализирани**), получаваме **идентично** копие на данните.

Нека имаме някаква структура, пазеща определена информация. Тази структура живее в паметта на нашата програма, но какво става когато спрем програмата? Данните, които тази структура пази, се губят. Какво правим, когато искаме при следващото стартиране на програмата отново да имаме тези данни?

Едно решение е да ги **сериализираме** във файл. Следващия път, когато имаме нужда от тях, просто ги **десериализираме**.

---

## Задача трета
Да се създаде структура pair, която представлява наредена двойка от естествени числа.
Да се реализират следните функции:
* pair createPair(int x, int y); - Връща двойка с елементи x и y.
* void initPair(pair& toInit, int x, int y); - Дава стойности x и y на toInit.
* pair readPairFromFile(std::ifstream& inFile); - Прочита двойка от файл.
* void writePairToFile(std::ofstream& outFile, const pair& toWrite); - Записва двойка във файл.

Да се създаде структура, която представлява релация с най-много 25 наредени двойки. Структурата също трябва да пази колко наредени двойки имаме до този момент. Реализирайте функции:
* bool addPair(relation& arg, pair& toInsert); - Добавя нова наредена двойка, ако има място. Ако няма връща false.
* bool writeRelation(const relation& arg, const char* filePath) - Записва (сериализира) релацията във файл.
* bool readRelation(relation& arg, const char* filepath) - Прочита (десериализира) релацията от файл.

Начинът, по който програмата чете и записва обектите във файлове, е ваша отговорност.

## Задача четвърта
Да се реализира структура, която представлява запис (log). Записът се представя като:
* Име на потребител с дължина 16
* ip(v4) адрес на потребителя (спомнете си как представихме ip адрес на лекции за улеснение)
* Час, минути и секунди на логът (можете да направите отделна структура за това, за която да имате помощни функции)

Да се реализират:
* bool writeLog(const log& toWrite, std::ofstream& outFile); - записва лог във файл.
* bool writeLogs(log* logs, size_t size, const char* filePath); - Записва масив от логове във файл
* bool readLog(log& toRead, std::ifstream& inFile); - прочита лог от файл
* size_t logsCount(const char* filePath); - Връща броя на логовете записани във файл
* size_t readLogs(log* logs, const char* filePath); - Прочита логовете от файл и връща броят им. Ако възникне грешка функцията връща 0.

Помислете как ще реализирате записването във файл, така че четенето да е максимално лесно.

## Задача пета
Да се реализира структура, която моделира потребител в дадена информационна система. За всеки потребител трябва да се пазят:
* потребителско име - дължина до 32 символа, може да съдържа букви, цифри, -, _, .
* парола - най-малко 8 символа, най-много 32, трябва да съдържа поне една главна буква, малка буква и цифра (за улеснение нека приемем, че паролата се пази в чист вид, макар това да е изключително лоша практика в реалните информационни системи!)
* имейл адрес - дължина до 32 символа

Потребителите във вашата информационната система се съхраняват в един CSV файл, като те не могат да надброяват 100.
Потребителското име е уникално за всеки потребител.
НЕ може да има повече от един потребител, регистриран с даден имейл адрес.

Да се реализират следните функционалности:
* Добавяне на нов потребител.
* Вход в системата посредством потребителско име и парола.
* Промяна на паролата (след вход в системата).

Обърнете внимание на ограниченията при имплементацията на всяка от функционалностите!

Реализирайте подходящ интерфейс на конзолата за всяка от имплементираните функционалности на вашата информационна система.
