# Практикум 21.03.2022

## Задача първа
Да се реализира клас Time. Класът трябва да поддържа:
---
* Конструктор по подразбиране, който задава времето на 0:0:0
* Конструктор с три параметъра, който приема съответно часове, минути и секунди
* Конструктор с един параметър (size_t) който приема число, представляващо броя секунди минали от полунощ. ``` n = 3600 * hrs + 60 * mins + secs```
---
* Функции getHours, getMinutes, getSeconds
* Функции setHours, setMinutes, setSeconds
---
* Функция bool compareTime(const Time& other); която връща true ако other е по - късно от сегашното време и false в противен случай.
* Да се напише функция, която връща времето оставащо до полунощ.

## Задача втора
Последния път реализирахме динамичен масив, който поддържаше следните операции:
* push_back(int) - добавя елемент в края
* operator[](size_t idx) - взема елемент на индекс
* pop_back() - премахва елемент

Този път ще реализираме нещо подобно. Вече елементите вместо наредба имат ранк:
* void push_back(int elem, size_t rank);

Когато изваждаме елемент искаме да извадим този с най - висок ранг. Ако имаме няколко елемента с най - висок ранг изваждаме някой от тях.
С други думи трябва да поддържаме:
* int getElementWithBiggestRank();  -- Връща елемента с най - голям ранг и го премахва от колекцията.
* int peak() const;                 -- Връща елемента с най - голям ранг.

Допълнително:
Това далечно напомня на структурата приоритетна опашка. Там имената на тези функции са:
* void enqueue(int elem, size_t rank) - добави елемент в опашката
* int peak() const;                   - Погледни най - тежкия елемент
* int dequeue();                      - Премахни най - тежкия елемент в колекцията (и го върни).

Работата с паметта е ваша отговорност. Не се изисква операциите да са "бързи".


